<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>MSP430 DriverLib for MSP430FR5xx_6xx Devices: adc12_b</title>
<title>adc12_b</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
<tbody>
<tr style="height: 56px;">
  <td bgcolor="black" width="1">
    <a href="http://www.ti.com">
	  <img border="0" src="tilogo.gif" />
	</a>
  </td>
  <td bgcolor="red">
    <img src="titagline.gif" />
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MSP430 DriverLib for MSP430FR5xx_6xx Devices
   &#160;<span id="projectnumber">2.91.00.20</span>
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief"></div>
    </td>
   <!--td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td-->
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__adc12__b__api.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">adc12_b</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaae98ec2541a80ac51296d330d74b7191"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gaae98ec2541a80ac51296d330d74b7191">ADC12_B_init</a> (uint16_t baseAddress, <a class="el" href="struct_a_d_c12___b__init_param.html">ADC12_B_initParam</a> *param)</td></tr>
<tr class="memdesc:gaae98ec2541a80ac51296d330d74b7191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the ADC12B Module.  <a href="#gaae98ec2541a80ac51296d330d74b7191">More...</a><br /></td></tr>
<tr class="separator:gaae98ec2541a80ac51296d330d74b7191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732106847a6dbfab493a9f94b205f7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga732106847a6dbfab493a9f94b205f7d8">ADC12_B_enable</a> (uint16_t baseAddress)</td></tr>
<tr class="memdesc:ga732106847a6dbfab493a9f94b205f7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the ADC12B block.  <a href="#ga732106847a6dbfab493a9f94b205f7d8">More...</a><br /></td></tr>
<tr class="separator:ga732106847a6dbfab493a9f94b205f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75ab10be34d43f74a404716744fd181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gab75ab10be34d43f74a404716744fd181">ADC12_B_disable</a> (uint16_t baseAddress)</td></tr>
<tr class="memdesc:gab75ab10be34d43f74a404716744fd181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the ADC12B block.  <a href="#gab75ab10be34d43f74a404716744fd181">More...</a><br /></td></tr>
<tr class="separator:gab75ab10be34d43f74a404716744fd181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e95b32626323f82beafc09f2c6700e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga08e95b32626323f82beafc09f2c6700e">ADC12_B_setupSamplingTimer</a> (uint16_t baseAddress, uint16_t clockCycleHoldCountLowMem, uint16_t clockCycleHoldCountHighMem, uint16_t multipleSamplesEnabled)</td></tr>
<tr class="memdesc:ga08e95b32626323f82beafc09f2c6700e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up and enables the Sampling Timer Pulse Mode.  <a href="#ga08e95b32626323f82beafc09f2c6700e">More...</a><br /></td></tr>
<tr class="separator:ga08e95b32626323f82beafc09f2c6700e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47403f54aaabb002d3968907e4cae58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gad47403f54aaabb002d3968907e4cae58">ADC12_B_disableSamplingTimer</a> (uint16_t baseAddress)</td></tr>
<tr class="memdesc:gad47403f54aaabb002d3968907e4cae58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables Sampling Timer Pulse Mode.  <a href="#gad47403f54aaabb002d3968907e4cae58">More...</a><br /></td></tr>
<tr class="separator:gad47403f54aaabb002d3968907e4cae58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e49f197a6b7726138838e80797b23a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga8e49f197a6b7726138838e80797b23a8">ADC12_B_configureMemory</a> (uint16_t baseAddress, <a class="el" href="struct_a_d_c12___b__configure_memory_param.html">ADC12_B_configureMemoryParam</a> *param)</td></tr>
<tr class="memdesc:ga8e49f197a6b7726138838e80797b23a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the controls of the selected memory buffer.  <a href="#ga8e49f197a6b7726138838e80797b23a8">More...</a><br /></td></tr>
<tr class="separator:ga8e49f197a6b7726138838e80797b23a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga243d8f526626358f7893d183b9b86af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga243d8f526626358f7893d183b9b86af5">ADC12_B_setWindowCompAdvanced</a> (uint16_t baseAddress, uint16_t highThreshold, uint16_t lowThreshold)</td></tr>
<tr class="memdesc:ga243d8f526626358f7893d183b9b86af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the high and low threshold for the window comparator feature.  <a href="#ga243d8f526626358f7893d183b9b86af5">More...</a><br /></td></tr>
<tr class="separator:ga243d8f526626358f7893d183b9b86af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga298ca414479cf2dcbce94c316a63ea1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga298ca414479cf2dcbce94c316a63ea1d">ADC12_B_enableInterrupt</a> (uint16_t baseAddress, uint16_t interruptMask0, uint16_t interruptMask1, uint16_t interruptMask2)</td></tr>
<tr class="memdesc:ga298ca414479cf2dcbce94c316a63ea1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables selected ADC12B interrupt sources.  <a href="#ga298ca414479cf2dcbce94c316a63ea1d">More...</a><br /></td></tr>
<tr class="separator:ga298ca414479cf2dcbce94c316a63ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c589919469fb9da8df5d5f3953e8b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga1c589919469fb9da8df5d5f3953e8b0b">ADC12_B_disableInterrupt</a> (uint16_t baseAddress, uint16_t interruptMask0, uint16_t interruptMask1, uint16_t interruptMask2)</td></tr>
<tr class="memdesc:ga1c589919469fb9da8df5d5f3953e8b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables selected ADC12B interrupt sources.  <a href="#ga1c589919469fb9da8df5d5f3953e8b0b">More...</a><br /></td></tr>
<tr class="separator:ga1c589919469fb9da8df5d5f3953e8b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd76e4e27bcd190a94ca951b668ef4c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gacd76e4e27bcd190a94ca951b668ef4c9">ADC12_B_clearInterrupt</a> (uint16_t baseAddress, uint8_t interruptRegisterChoice, uint16_t memoryInterruptFlagMask)</td></tr>
<tr class="memdesc:gacd76e4e27bcd190a94ca951b668ef4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears ADC12B selected interrupt flags.  <a href="#gacd76e4e27bcd190a94ca951b668ef4c9">More...</a><br /></td></tr>
<tr class="separator:gacd76e4e27bcd190a94ca951b668ef4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62910e56616d0334d2a78c0375c659b9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga62910e56616d0334d2a78c0375c659b9">ADC12_B_getInterruptStatus</a> (uint16_t baseAddress, uint8_t interruptRegisterChoice, uint16_t memoryInterruptFlagMask)</td></tr>
<tr class="memdesc:ga62910e56616d0334d2a78c0375c659b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the selected memory interrupt flags.  <a href="#ga62910e56616d0334d2a78c0375c659b9">More...</a><br /></td></tr>
<tr class="separator:ga62910e56616d0334d2a78c0375c659b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86b3b7ae3d00d2c5da536a5a415521d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gae86b3b7ae3d00d2c5da536a5a415521d">ADC12_B_startConversion</a> (uint16_t baseAddress, uint16_t startingMemoryBufferIndex, uint8_t conversionSequenceModeSelect)</td></tr>
<tr class="memdesc:gae86b3b7ae3d00d2c5da536a5a415521d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Starts an Analog-to-Digital Conversion.  <a href="#gae86b3b7ae3d00d2c5da536a5a415521d">More...</a><br /></td></tr>
<tr class="separator:gae86b3b7ae3d00d2c5da536a5a415521d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9f67cb246f989ad38bd364cab9ee71a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gaa9f67cb246f989ad38bd364cab9ee71a">ADC12_B_disableConversions</a> (uint16_t baseAddress, bool preempt)</td></tr>
<tr class="memdesc:gaa9f67cb246f989ad38bd364cab9ee71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the ADC from converting any more signals.  <a href="#gaa9f67cb246f989ad38bd364cab9ee71a">More...</a><br /></td></tr>
<tr class="separator:gaa9f67cb246f989ad38bd364cab9ee71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d08219c7722d20ee86e981cad87f5c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga00d08219c7722d20ee86e981cad87f5c">ADC12_B_getResults</a> (uint16_t baseAddress, uint8_t memoryBufferIndex)</td></tr>
<tr class="memdesc:ga00d08219c7722d20ee86e981cad87f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw contents of the specified memory buffer.  <a href="#ga00d08219c7722d20ee86e981cad87f5c">More...</a><br /></td></tr>
<tr class="separator:ga00d08219c7722d20ee86e981cad87f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18034a2ced0dbc6a396697ad5ad1b434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga18034a2ced0dbc6a396697ad5ad1b434">ADC12_B_setResolution</a> (uint16_t baseAddress, uint8_t resolutionSelect)</td></tr>
<tr class="memdesc:ga18034a2ced0dbc6a396697ad5ad1b434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to change the resolution of the converted data.  <a href="#ga18034a2ced0dbc6a396697ad5ad1b434">More...</a><br /></td></tr>
<tr class="separator:ga18034a2ced0dbc6a396697ad5ad1b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga638529ecbfd7c986d45a117d5927d718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga638529ecbfd7c986d45a117d5927d718">ADC12_B_setSampleHoldSignalInversion</a> (uint16_t baseAddress, uint16_t invertedSignal)</td></tr>
<tr class="memdesc:ga638529ecbfd7c986d45a117d5927d718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to invert or un-invert the sample/hold signal.  <a href="#ga638529ecbfd7c986d45a117d5927d718">More...</a><br /></td></tr>
<tr class="separator:ga638529ecbfd7c986d45a117d5927d718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4f949a48bd1509f0dbf3a33f778567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga5f4f949a48bd1509f0dbf3a33f778567">ADC12_B_setDataReadBackFormat</a> (uint16_t baseAddress, uint8_t readBackFormat)</td></tr>
<tr class="memdesc:ga5f4f949a48bd1509f0dbf3a33f778567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to set the read-back format of the converted data.  <a href="#ga5f4f949a48bd1509f0dbf3a33f778567">More...</a><br /></td></tr>
<tr class="separator:ga5f4f949a48bd1509f0dbf3a33f778567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd3c6243806a80c1598ab13debdefd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga2dd3c6243806a80c1598ab13debdefd9">ADC12_B_setAdcPowerMode</a> (uint16_t baseAddress, uint8_t powerMode)</td></tr>
<tr class="memdesc:ga2dd3c6243806a80c1598ab13debdefd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to set the ADC's power conservation mode if the sampling rate is at 50-ksps or less.  <a href="#ga2dd3c6243806a80c1598ab13debdefd9">More...</a><br /></td></tr>
<tr class="separator:ga2dd3c6243806a80c1598ab13debdefd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54ba19bce539f2ffa71567e5fdbcd18"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#gae54ba19bce539f2ffa71567e5fdbcd18">ADC12_B_getMemoryAddressForDMA</a> (uint16_t baseAddress, uint8_t memoryIndex)</td></tr>
<tr class="memdesc:gae54ba19bce539f2ffa71567e5fdbcd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the specified memory buffer for the DMA module.  <a href="#gae54ba19bce539f2ffa71567e5fdbcd18">More...</a><br /></td></tr>
<tr class="separator:gae54ba19bce539f2ffa71567e5fdbcd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a28d89d48217944924df968335c8e8e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__adc12__b__api.html#ga2a28d89d48217944924df968335c8e8e">ADC12_B_isBusy</a> (uint16_t baseAddress)</td></tr>
<tr class="memdesc:ga2a28d89d48217944924df968335c8e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the busy status of the ADC12B core.  <a href="#ga2a28d89d48217944924df968335c8e8e">More...</a><br /></td></tr>
<tr class="separator:ga2a28d89d48217944924df968335c8e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gacd76e4e27bcd190a94ca951b668ef4c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_clearInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interruptRegisterChoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>memoryInterruptFlagMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears ADC12B selected interrupt flags. </p>
<p>Modified registers are ADC12IFG .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">interruptRegisterChoice</td><td>is either 0, 1, or 2, to choose the correct interrupt register to update </td></tr>
    <tr><td class="paramname">memoryInterruptFlagMask</td><td>is the bit mask of the memory buffer and overflow interrupt flags to be cleared. Valid values are:<ul>
<li><b>ADC12_B_IFG0</b> - interruptRegisterChoice = 0</li>
<li><b>ADC12_B_IFG1</b> </li>
<li><b>ADC12_B_IFG2</b> </li>
<li><b>ADC12_B_IFG3</b> </li>
<li><b>ADC12_B_IFG4</b> </li>
<li><b>ADC12_B_IFG5</b> </li>
<li><b>ADC12_B_IFG6</b> </li>
<li><b>ADC12_B_IFG7</b> </li>
<li><b>ADC12_B_IFG8</b> </li>
<li><b>ADC12_B_IFG9</b> </li>
<li><b>ADC12_B_IFG10</b> </li>
<li><b>ADC12_B_IFG11</b> </li>
<li><b>ADC12_B_IFG12</b> </li>
<li><b>ADC12_B_IFG13</b> </li>
<li><b>ADC12_B_IFG14</b> </li>
<li><b>ADC12_B_IFG15</b> </li>
<li><b>ADC12_B_IFG16</b> - interruptRegisterChoice = 1</li>
<li><b>ADC12_B_IFG17</b> </li>
<li><b>ADC12_B_IFG18</b> </li>
<li><b>ADC12_B_IFG19</b> </li>
<li><b>ADC12_B_IFG20</b> </li>
<li><b>ADC12_B_IFG21</b> </li>
<li><b>ADC12_B_IFG22</b> </li>
<li><b>ADC12_B_IFG23</b> </li>
<li><b>ADC12_B_IFG24</b> </li>
<li><b>ADC12_B_IFG25</b> </li>
<li><b>ADC12_B_IFG26</b> </li>
<li><b>ADC12_B_IFG27</b> </li>
<li><b>ADC12_B_IFG28</b> </li>
<li><b>ADC12_B_IFG29</b> </li>
<li><b>ADC12_B_IFG30</b> </li>
<li><b>ADC12_B_IFG31</b> </li>
<li><b>ADC12_B_INIFG</b> - interruptRegisterChoice = 2</li>
<li><b>ADC12_B_LOIFG</b> </li>
<li><b>ADC12_B_HIIFG</b> </li>
<li><b>ADC12_B_OVIFG</b> </li>
<li><b>ADC12_B_TOVIFG</b> </li>
<li><b>ADC12_B_RDYIFG</b> - The selected ADC12B interrupt flags are cleared, so that it no longer asserts. The memory buffer interrupt flags are only cleared when the memory buffer is accessed. Note that the overflow interrupts do not have an interrupt flag to clear; they must be accessed directly from the interrupt vector.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e49f197a6b7726138838e80797b23a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_configureMemory </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_c12___b__configure_memory_param.html">ADC12_B_configureMemoryParam</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the controls of the selected memory buffer. </p>
<p>Maps an input signal conversion into the selected memory buffer, as well as the positive and negative reference voltages for each conversion being stored into this memory buffer. If the internal reference is used for the positive reference voltage, the internal REF module must be used to control the voltage level. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called. If conversion is not disabled, this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">param</td><td>is the pointer to struct for ADC12B memory configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_a_d_c12___b__configure_memory_param.html#aa8e77a6d6409ce7e1c12afb52981c13b">ADC12_B_configureMemoryParam::differentialModeSelect</a>, <a class="el" href="struct_a_d_c12___b__configure_memory_param.html#ab115b764006e293320bc0b469889ab4b">ADC12_B_configureMemoryParam::endOfSequence</a>, <a class="el" href="struct_a_d_c12___b__configure_memory_param.html#a7d4f49361aa04cb994c22c45f852b220">ADC12_B_configureMemoryParam::inputSourceSelect</a>, <a class="el" href="struct_a_d_c12___b__configure_memory_param.html#adb9fe9affede375174f931db0713d14a">ADC12_B_configureMemoryParam::memoryBufferControlIndex</a>, <a class="el" href="struct_a_d_c12___b__configure_memory_param.html#aa2a746d294d3d7abf88991a9306cb919">ADC12_B_configureMemoryParam::refVoltageSourceSelect</a>, and <a class="el" href="struct_a_d_c12___b__configure_memory_param.html#a0bff92d26e70bf141f306f367ddacd32">ADC12_B_configureMemoryParam::windowComparatorSelect</a>.</p>

</div>
</div>
<a class="anchor" id="gab75ab10be34d43f74a404716744fd181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the ADC12B block. </p>
<p>This will disable operation of the ADC12B block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module.</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits are <b>ADC12ON</b> of <b>ADC12CTL0</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9f67cb246f989ad38bd364cab9ee71a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_disableConversions </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preempt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the ADC from converting any more signals. </p>
<p>Disables the ADC from converting any more signals. If there is a conversion in progress, this function can stop it immediately if the preempt parameter is set as ADC12_B_PREEMPTCONVERSION, by changing the conversion mode to single-channel, single-conversion and disabling conversions. If the conversion mode is set as single-channel, single-conversion and this function is called without preemption, then the ADC core conversion status is polled until the conversion is complete before disabling conversions to prevent unpredictable data. If the <a class="el" href="group__adc12__b__api.html#gae86b3b7ae3d00d2c5da536a5a415521d" title="Enables/Starts an Analog-to-Digital Conversion. ">ADC12_B_startConversion()</a> has been called, then this function has to be called to re-initialize the ADC, reconfigure a memory buffer control, enable/disable the sampling pulse mode, or change the internal reference voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">preempt</td><td>specifies if the current conversion should be preemptively stopped before the end of the conversion. Valid values are:<ul>
<li><b>ADC12_B_COMPLETECONVERSION</b> - Allows the ADC12B to end the current conversion before disabling conversions.</li>
<li><b>ADC12_B_PREEMPTCONVERSION</b> - Stops the ADC12B immediately, with unpredictable results of the current conversion.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits of <b>ADC12CTL1</b> register and bits of <b>ADC12CTL0</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>References <a class="el" href="group__adc12__b__api.html#ga2a28d89d48217944924df968335c8e8e">ADC12_B_isBusy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c589919469fb9da8df5d5f3953e8b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interruptMask0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interruptMask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interruptMask2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables selected ADC12B interrupt sources. </p>
<p>Disables the indicated ADC12B interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">interruptMask0</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be disabled. If the desired interrupt is not available in the selection for interruptMask0, then simply pass in a '0' for this value. Valid values are:<ul>
<li><b>ADC12_B_IE0</b> </li>
<li><b>ADC12_B_IE1</b> </li>
<li><b>ADC12_B_IE2</b> </li>
<li><b>ADC12_B_IE3</b> </li>
<li><b>ADC12_B_IE4</b> </li>
<li><b>ADC12_B_IE5</b> </li>
<li><b>ADC12_B_IE6</b> </li>
<li><b>ADC12_B_IE7</b> </li>
<li><b>ADC12_B_IE8</b> </li>
<li><b>ADC12_B_IE9</b> </li>
<li><b>ADC12_B_IE10</b> </li>
<li><b>ADC12_B_IE11</b> </li>
<li><b>ADC12_B_IE12</b> </li>
<li><b>ADC12_B_IE13</b> </li>
<li><b>ADC12_B_IE14</b> </li>
<li><b>ADC12_B_IE15</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">interruptMask1</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be disabled. If the desired interrupt is not available in the selection for interruptMask1, then simply pass in a '0' for this value. Valid values are:<ul>
<li><b>ADC12_B_IE16</b> </li>
<li><b>ADC12_B_IE17</b> </li>
<li><b>ADC12_B_IE18</b> </li>
<li><b>ADC12_B_IE19</b> </li>
<li><b>ADC12_B_IE20</b> </li>
<li><b>ADC12_B_IE21</b> </li>
<li><b>ADC12_B_IE22</b> </li>
<li><b>ADC12_B_IE23</b> </li>
<li><b>ADC12_B_IE24</b> </li>
<li><b>ADC12_B_IE25</b> </li>
<li><b>ADC12_B_IE26</b> </li>
<li><b>ADC12_B_IE27</b> </li>
<li><b>ADC12_B_IE28</b> </li>
<li><b>ADC12_B_IE29</b> </li>
<li><b>ADC12_B_IE30</b> </li>
<li><b>ADC12_B_IE31</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">interruptMask2</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be disabled. If the desired interrupt is not available in the selection for interruptMask2, then simply pass in a '0' for this value. Valid values are:<ul>
<li><b>ADC12_B_INIE</b> - Interrupt enable for a conversion in the result register is either greater than the ADC12LO or lower than the ADC12HI threshold. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_LOIE</b> - Interrupt enable for the falling short of the lower limit interrupt of the window comparator for the result register. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_HIIE</b> - Interrupt enable for the exceeding the upper limit of the window comparator for the result register. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_OVIE</b> - Interrupt enable for a conversion that is about to save to a memory buffer that has not been read out yet. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_TOVIE</b> - enable for a conversion that is about to start before the previous conversion has been completed. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_RDYIE</b> - enable for the local buffered reference ready signal. GIE bit must be set to enable the interrupt.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits of <b>ADC12IERx</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad47403f54aaabb002d3968907e4cae58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_disableSamplingTimer </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables Sampling Timer Pulse Mode. </p>
<p>Disables the Sampling Timer Pulse Mode. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga732106847a6dbfab493a9f94b205f7d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the ADC12B block. </p>
<p>This will enable operation of the ADC12B block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module.</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits are <b>ADC12ON</b> of <b>ADC12CTL0</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga298ca414479cf2dcbce94c316a63ea1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interruptMask0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interruptMask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interruptMask2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables selected ADC12B interrupt sources. </p>
<p>Enables the indicated ADC12B interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor. <b>Does not clear interrupt flags.</b></p>
<p><b></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">interruptMask0</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be enabled. If the desired interrupt is not available in the selection for interruptMask0, then simply pass in a '0' for this value. Valid values are:<ul>
<li><b>ADC12_B_IE0</b> </li>
<li><b>ADC12_B_IE1</b> </li>
<li><b>ADC12_B_IE2</b> </li>
<li><b>ADC12_B_IE3</b> </li>
<li><b>ADC12_B_IE4</b> </li>
<li><b>ADC12_B_IE5</b> </li>
<li><b>ADC12_B_IE6</b> </li>
<li><b>ADC12_B_IE7</b> </li>
<li><b>ADC12_B_IE8</b> </li>
<li><b>ADC12_B_IE9</b> </li>
<li><b>ADC12_B_IE10</b> </li>
<li><b>ADC12_B_IE11</b> </li>
<li><b>ADC12_B_IE12</b> </li>
<li><b>ADC12_B_IE13</b> </li>
<li><b>ADC12_B_IE14</b> </li>
<li><b>ADC12_B_IE15</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">interruptMask1</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be enabled. If the desired interrupt is not available in the selection for interruptMask1, then simply pass in a '0' for this value. Valid values are:<ul>
<li><b>ADC12_B_IE16</b> </li>
<li><b>ADC12_B_IE17</b> </li>
<li><b>ADC12_B_IE18</b> </li>
<li><b>ADC12_B_IE19</b> </li>
<li><b>ADC12_B_IE20</b> </li>
<li><b>ADC12_B_IE21</b> </li>
<li><b>ADC12_B_IE22</b> </li>
<li><b>ADC12_B_IE23</b> </li>
<li><b>ADC12_B_IE24</b> </li>
<li><b>ADC12_B_IE25</b> </li>
<li><b>ADC12_B_IE26</b> </li>
<li><b>ADC12_B_IE27</b> </li>
<li><b>ADC12_B_IE28</b> </li>
<li><b>ADC12_B_IE29</b> </li>
<li><b>ADC12_B_IE30</b> </li>
<li><b>ADC12_B_IE31</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">interruptMask2</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be enabled. If the desired interrupt is not available in the selection for interruptMask2, then simply pass in a '0' for this value. Valid values are:<ul>
<li><b>ADC12_B_INIE</b> - Interrupt enable for a conversion in the result register is either greater than the ADC12LO or lower than the ADC12HI threshold. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_LOIE</b> - Interrupt enable for the falling short of the lower limit interrupt of the window comparator for the result register. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_HIIE</b> - Interrupt enable for the exceeding the upper limit of the window comparator for the result register. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_OVIE</b> - Interrupt enable for a conversion that is about to save to a memory buffer that has not been read out yet. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_TOVIE</b> - enable for a conversion that is about to start before the previous conversion has been completed. GIE bit must be set to enable the interrupt.</li>
<li><b>ADC12_B_RDYIE</b> - enable for the local buffered reference ready signal. GIE bit must be set to enable the interrupt.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits of <b>ADC12IERx</b> register.</b></p>
<p><b></p><dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<p></b></p>

</div>
</div>
<a class="anchor" id="ga62910e56616d0334d2a78c0375c659b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ADC12_B_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interruptRegisterChoice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>memoryInterruptFlagMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the selected memory interrupt flags. </p>
<p>Returns the status of the selected memory interrupt flags. Note that the overflow interrupts do not have an interrupt flag to clear; they must be accessed directly from the interrupt vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">interruptRegisterChoice</td><td>is either 0, 1, or 2, to choose the correct interrupt register to update </td></tr>
    <tr><td class="paramname">memoryInterruptFlagMask</td><td>is the bit mask of the memory buffer and overflow interrupt flags to be cleared. Valid values are:<ul>
<li><b>ADC12_B_IFG0</b> - interruptRegisterChoice = 0</li>
<li><b>ADC12_B_IFG1</b> </li>
<li><b>ADC12_B_IFG2</b> </li>
<li><b>ADC12_B_IFG3</b> </li>
<li><b>ADC12_B_IFG4</b> </li>
<li><b>ADC12_B_IFG5</b> </li>
<li><b>ADC12_B_IFG6</b> </li>
<li><b>ADC12_B_IFG7</b> </li>
<li><b>ADC12_B_IFG8</b> </li>
<li><b>ADC12_B_IFG9</b> </li>
<li><b>ADC12_B_IFG10</b> </li>
<li><b>ADC12_B_IFG11</b> </li>
<li><b>ADC12_B_IFG12</b> </li>
<li><b>ADC12_B_IFG13</b> </li>
<li><b>ADC12_B_IFG14</b> </li>
<li><b>ADC12_B_IFG15</b> </li>
<li><b>ADC12_B_IFG16</b> - interruptRegisterChoice = 1</li>
<li><b>ADC12_B_IFG17</b> </li>
<li><b>ADC12_B_IFG18</b> </li>
<li><b>ADC12_B_IFG19</b> </li>
<li><b>ADC12_B_IFG20</b> </li>
<li><b>ADC12_B_IFG21</b> </li>
<li><b>ADC12_B_IFG22</b> </li>
<li><b>ADC12_B_IFG23</b> </li>
<li><b>ADC12_B_IFG24</b> </li>
<li><b>ADC12_B_IFG25</b> </li>
<li><b>ADC12_B_IFG26</b> </li>
<li><b>ADC12_B_IFG27</b> </li>
<li><b>ADC12_B_IFG28</b> </li>
<li><b>ADC12_B_IFG29</b> </li>
<li><b>ADC12_B_IFG30</b> </li>
<li><b>ADC12_B_IFG31</b> </li>
<li><b>ADC12_B_INIFG</b> - interruptRegisterChoice = 2</li>
<li><b>ADC12_B_LOIFG</b> </li>
<li><b>ADC12_B_HIIFG</b> </li>
<li><b>ADC12_B_OVIFG</b> </li>
<li><b>ADC12_B_TOVIFG</b> </li>
<li><b>ADC12_B_RDYIFG</b> - The selected ADC12B interrupt flags are cleared, so that it no longer asserts. The memory buffer interrupt flags are only cleared when the memory buffer is accessed. Note that the overflow interrupts do not have an interrupt flag to clear; they must be accessed directly from the interrupt vector.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt flag status for the corresponding mask. </dd></dl>

</div>
</div>
<a class="anchor" id="gae54ba19bce539f2ffa71567e5fdbcd18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ADC12_B_getMemoryAddressForDMA </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memoryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the address of the specified memory buffer for the DMA module. </p>
<p>Returns the address of the specified memory buffer. This can be used in conjunction with the DMA to store the converted data directly to memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">memoryIndex</td><td>is the memory buffer to return the address of. Valid values are:<ul>
<li><b>ADC12_B_MEMORY_0</b> </li>
<li><b>ADC12_B_MEMORY_1</b> </li>
<li><b>ADC12_B_MEMORY_2</b> </li>
<li><b>ADC12_B_MEMORY_3</b> </li>
<li><b>ADC12_B_MEMORY_4</b> </li>
<li><b>ADC12_B_MEMORY_5</b> </li>
<li><b>ADC12_B_MEMORY_6</b> </li>
<li><b>ADC12_B_MEMORY_7</b> </li>
<li><b>ADC12_B_MEMORY_8</b> </li>
<li><b>ADC12_B_MEMORY_9</b> </li>
<li><b>ADC12_B_MEMORY_10</b> </li>
<li><b>ADC12_B_MEMORY_11</b> </li>
<li><b>ADC12_B_MEMORY_12</b> </li>
<li><b>ADC12_B_MEMORY_13</b> </li>
<li><b>ADC12_B_MEMORY_14</b> </li>
<li><b>ADC12_B_MEMORY_15</b> </li>
<li><b>ADC12_B_MEMORY_16</b> </li>
<li><b>ADC12_B_MEMORY_17</b> </li>
<li><b>ADC12_B_MEMORY_18</b> </li>
<li><b>ADC12_B_MEMORY_19</b> </li>
<li><b>ADC12_B_MEMORY_20</b> </li>
<li><b>ADC12_B_MEMORY_21</b> </li>
<li><b>ADC12_B_MEMORY_22</b> </li>
<li><b>ADC12_B_MEMORY_23</b> </li>
<li><b>ADC12_B_MEMORY_24</b> </li>
<li><b>ADC12_B_MEMORY_25</b> </li>
<li><b>ADC12_B_MEMORY_26</b> </li>
<li><b>ADC12_B_MEMORY_27</b> </li>
<li><b>ADC12_B_MEMORY_28</b> </li>
<li><b>ADC12_B_MEMORY_29</b> </li>
<li><b>ADC12_B_MEMORY_30</b> </li>
<li><b>ADC12_B_MEMORY_31</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the specified memory buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ga00d08219c7722d20ee86e981cad87f5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ADC12_B_getResults </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>memoryBufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the raw contents of the specified memory buffer. </p>
<p>Returns the raw contents of the specified memory buffer. The format of the content depends on the read-back format of the data: if the data is in signed 2's complement format then the contents in the memory buffer will be left-justified with the least-significant bits as 0's, whereas if the data is in unsigned format then the contents in the memory buffer will be right- justified with the most-significant bits as 0's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">memoryBufferIndex</td><td>is the specified memory buffer to read. Valid values are:<ul>
<li><b>ADC12_B_MEMORY_0</b> </li>
<li><b>ADC12_B_MEMORY_1</b> </li>
<li><b>ADC12_B_MEMORY_2</b> </li>
<li><b>ADC12_B_MEMORY_3</b> </li>
<li><b>ADC12_B_MEMORY_4</b> </li>
<li><b>ADC12_B_MEMORY_5</b> </li>
<li><b>ADC12_B_MEMORY_6</b> </li>
<li><b>ADC12_B_MEMORY_7</b> </li>
<li><b>ADC12_B_MEMORY_8</b> </li>
<li><b>ADC12_B_MEMORY_9</b> </li>
<li><b>ADC12_B_MEMORY_10</b> </li>
<li><b>ADC12_B_MEMORY_11</b> </li>
<li><b>ADC12_B_MEMORY_12</b> </li>
<li><b>ADC12_B_MEMORY_13</b> </li>
<li><b>ADC12_B_MEMORY_14</b> </li>
<li><b>ADC12_B_MEMORY_15</b> </li>
<li><b>ADC12_B_MEMORY_16</b> </li>
<li><b>ADC12_B_MEMORY_17</b> </li>
<li><b>ADC12_B_MEMORY_18</b> </li>
<li><b>ADC12_B_MEMORY_19</b> </li>
<li><b>ADC12_B_MEMORY_20</b> </li>
<li><b>ADC12_B_MEMORY_21</b> </li>
<li><b>ADC12_B_MEMORY_22</b> </li>
<li><b>ADC12_B_MEMORY_23</b> </li>
<li><b>ADC12_B_MEMORY_24</b> </li>
<li><b>ADC12_B_MEMORY_25</b> </li>
<li><b>ADC12_B_MEMORY_26</b> </li>
<li><b>ADC12_B_MEMORY_27</b> </li>
<li><b>ADC12_B_MEMORY_28</b> </li>
<li><b>ADC12_B_MEMORY_29</b> </li>
<li><b>ADC12_B_MEMORY_30</b> </li>
<li><b>ADC12_B_MEMORY_31</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed integer of the contents of the specified memory buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae98ec2541a80ac51296d330d74b7191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ADC12_B_init </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_c12___b__init_param.html">ADC12_B_initParam</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the ADC12B Module. </p>
<p>This function initializes the ADC module to allow for analog-to-digital conversions. Specifically this function sets up the sample-and-hold signal and clock sources for the ADC core to use for conversions. Upon successful completion of the initialization all of the ADC control registers will be reset, excluding the memory controls and reference module bits, the given parameters will be set, and the ADC core will be turned on (Note, that the ADC core only draws power during conversions and remains off when not converting).Note that sample/hold signal sources are device dependent. Note that if re-initializing the ADC after starting a conversion with the startConversion() function, the disableConversion() must be called BEFORE this function can be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">param</td><td>is the pointer to struct for initialization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS or STATUS_FAILURE of the initialization process. </dd></dl>

<p>References <a class="el" href="struct_a_d_c12___b__init_param.html#a2c27d46dae0c4eccc1c8c62fbb6f1439">ADC12_B_initParam::clockSourceDivider</a>, <a class="el" href="struct_a_d_c12___b__init_param.html#ac7f05bb25c26dea9f760076243f9788c">ADC12_B_initParam::clockSourcePredivider</a>, <a class="el" href="struct_a_d_c12___b__init_param.html#a30926aa823f27fb5d9422bfca56f84bb">ADC12_B_initParam::clockSourceSelect</a>, <a class="el" href="struct_a_d_c12___b__init_param.html#af97e68933ee4c98cec96f70fed16e9fd">ADC12_B_initParam::internalChannelMap</a>, and <a class="el" href="struct_a_d_c12___b__init_param.html#aef647210d918b82e254cd4102eb6d8cf">ADC12_B_initParam::sampleHoldSignalSourceSelect</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a28d89d48217944924df968335c8e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ADC12_B_isBusy </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the busy status of the ADC12B core. </p>
<p>Returns the status of the ADC core if there is a conversion currently taking place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ADC12_B_BUSY or ADC12_B_NOTBUSY dependent if there is a conversion currently taking place. Return one of the following:<ul>
<li><b>ADC12_B_NOTBUSY</b> </li>
<li><b>ADC12_B_BUSY</b> <br />
 indicating if a conversion is taking place </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group__adc12__b__api.html#gaa9f67cb246f989ad38bd364cab9ee71a">ADC12_B_disableConversions()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2dd3c6243806a80c1598ab13debdefd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_setAdcPowerMode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>powerMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to set the ADC's power conservation mode if the sampling rate is at 50-ksps or less. </p>
<p>Sets ADC's power mode. If the user has a sampling rate greater than 50-ksps, then he/she can only enable ADC12_B_REGULARPOWERMODE. If the sampling rate is 50-ksps or less, the user can enable ADC12_B_LOWPOWERMODE granting additional power savings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">powerMode</td><td>is the specified maximum sampling rate. Valid values are:<ul>
<li><b>ADC12_B_REGULARPOWERMODE</b> [Default] - If sampling rate is greater than 50-ksps, there is no power saving feature available.</li>
<li><b>ADC12_B_LOWPOWERMODE</b> - If sampling rate is less than or equal to 50-ksps, select this value to save power <br />
 Modified bits are <b>ADC12SR</b> of <b>ADC12CTL2</b> register.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f4f949a48bd1509f0dbf3a33f778567"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_setDataReadBackFormat </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>readBackFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to set the read-back format of the converted data. </p>
<p>Sets the format of the converted data: how it will be stored into the memory buffer, and how it should be read back. The format can be set as right-justified (default), which indicates that the number will be unsigned, or left-justified, which indicates that the number will be signed in 2's complement format. This change affects all memory buffers for subsequent conversions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">readBackFormat</td><td>is the specified format to store the conversions in the memory buffer. Valid values are:<ul>
<li><b>ADC12_B_UNSIGNED_BINARY</b> [Default]</li>
<li><b>ADC12_B_SIGNED_2SCOMPLEMENT</b> <br />
 Modified bits are <b>ADC12DF</b> of <b>ADC12CTL2</b> register.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga18034a2ced0dbc6a396697ad5ad1b434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_setResolution </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>resolutionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to change the resolution of the converted data. </p>
<p>This function can be used to change the resolution of the converted data from the default of 12-bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">resolutionSelect</td><td>determines the resolution of the converted data. Valid values are:<ul>
<li><b>ADC12_B_RESOLUTION_8BIT</b> </li>
<li><b>ADC12_B_RESOLUTION_10BIT</b> </li>
<li><b>ADC12_B_RESOLUTION_12BIT</b> [Default] <br />
 Modified bits are <b>ADC12RESx</b> of <b>ADC12CTL2</b> register.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga638529ecbfd7c986d45a117d5927d718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_setSampleHoldSignalInversion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>invertedSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use to invert or un-invert the sample/hold signal. </p>
<p>This function can be used to invert or un-invert the sample/hold signal. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">invertedSignal</td><td>set if the sample/hold signal should be inverted Valid values are:<ul>
<li><b>ADC12_B_NONINVERTEDSIGNAL</b> [Default] - a sample-and-hold of an input signal for conversion will be started on a rising edge of the sample/hold signal.</li>
<li><b>ADC12_B_INVERTEDSIGNAL</b> - a sample-and-hold of an input signal for conversion will be started on a falling edge of the sample/hold signal. <br />
 Modified bits are <b>ADC12ISSH</b> of <b>ADC12CTL1</b> register.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga08e95b32626323f82beafc09f2c6700e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_setupSamplingTimer </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>clockCycleHoldCountLowMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>clockCycleHoldCountHighMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>multipleSamplesEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up and enables the Sampling Timer Pulse Mode. </p>
<p>This function sets up the sampling timer pulse mode which allows the sample/hold signal to trigger a sampling timer to sample-and-hold an input signal for a specified number of clock cycles without having to hold the sample/hold signal for the entire period of sampling. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">clockCycleHoldCountLowMem</td><td>sets the amount of clock cycles to sample- and-hold for the higher memory buffers 0-7. Valid values are:<ul>
<li><b>ADC12_B_CYCLEHOLD_4_CYCLES</b> [Default]</li>
<li><b>ADC12_B_CYCLEHOLD_8_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_16_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_32_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_64_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_96_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_128_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_192_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_256_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_384_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_512_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_768_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_1024_CYCLES</b> <br />
 Modified bits are <b>ADC12SHT0x</b> of <b>ADC12CTL0</b> register. </li>
</ul>
</td></tr>
    <tr><td class="paramname">clockCycleHoldCountHighMem</td><td>sets the amount of clock cycles to sample-and-hold for the higher memory buffers 8-15. Valid values are:<ul>
<li><b>ADC12_B_CYCLEHOLD_4_CYCLES</b> [Default]</li>
<li><b>ADC12_B_CYCLEHOLD_8_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_16_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_32_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_64_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_96_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_128_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_192_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_256_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_384_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_512_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_768_CYCLES</b> </li>
<li><b>ADC12_B_CYCLEHOLD_1024_CYCLES</b> <br />
 Modified bits are <b>ADC12SHT1x</b> of <b>ADC12CTL0</b> register. </li>
</ul>
</td></tr>
    <tr><td class="paramname">multipleSamplesEnabled</td><td>allows multiple conversions to start without a trigger signal from the sample/hold signal Valid values are:<ul>
<li><b>ADC12_B_MULTIPLESAMPLESDISABLE</b> [Default] - a timer trigger will be needed to start every ADC conversion.</li>
<li><b>ADC12_B_MULTIPLESAMPLESENABLE</b> - during a sequenced and/or repeated conversion mode, after the first conversion, no sample/hold signal is necessary to start subsequent sample/hold and convert processes. <br />
 Modified bits are <b>ADC12MSC</b> of <b>ADC12CTL0</b> register.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga243d8f526626358f7893d183b9b86af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_setWindowCompAdvanced </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>highThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>lowThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the high and low threshold for the window comparator feature. </p>
<p>Sets the high and low threshold for the window comparator feature. Use the ADC12HIIE, ADC12INIE, ADC12LOIE interrupts to utilize this feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">highThreshold</td><td>is the upper bound that could trip an interrupt for the window comparator. </td></tr>
    <tr><td class="paramname">lowThreshold</td><td>is the lower bound that could trip on interrupt for the window comparator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae86b3b7ae3d00d2c5da536a5a415521d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_B_startConversion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>startingMemoryBufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>conversionSequenceModeSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Starts an Analog-to-Digital Conversion. </p>
<p>Enables/starts the conversion process of the ADC. If the sample/hold signal source chosen during initialization was ADC12OSC, then the conversion is started immediately, otherwise the chosen sample/hold signal source starts the conversion by a rising edge of the signal. Keep in mind when selecting conversion modes, that for sequenced and/or repeated modes, to keep the sample/hold-and-convert process continuing without a trigger from the sample/hold signal source, the multiple samples must be enabled using the <a class="el" href="group__adc12__b__api.html#ga08e95b32626323f82beafc09f2c6700e" title="Sets up and enables the Sampling Timer Pulse Mode. ">ADC12_B_setupSamplingTimer()</a> function. Note that after this function is called, the ADC12_B_stopConversions() has to be called to re-initialize the ADC, reconfigure a memory buffer control, enable/disable the sampling timer, or to change the internal reference voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12B module. </td></tr>
    <tr><td class="paramname">startingMemoryBufferIndex</td><td>is the memory buffer that will hold the first or only conversion. Valid values are:<ul>
<li><b>ADC12_B_START_AT_ADC12MEM0</b> [Default]</li>
<li><b>ADC12_B_START_AT_ADC12MEM1</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM2</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM3</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM4</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM5</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM6</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM7</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM8</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM9</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM10</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM11</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM12</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM13</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM14</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM15</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM16</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM17</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM18</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM19</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM20</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM21</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM22</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM23</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM24</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM25</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM26</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM27</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM28</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM29</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM30</b> </li>
<li><b>ADC12_B_START_AT_ADC12MEM31</b> <br />
 Modified bits are <b>ADC12CSTARTADDx</b> of <b>ADC12CTL1</b> register. </li>
</ul>
</td></tr>
    <tr><td class="paramname">conversionSequenceModeSelect</td><td>determines the ADC operating mode. Valid values are:<ul>
<li><b>ADC12_B_SINGLECHANNEL</b> [Default] - one-time conversion of a single channel into a single memory buffer.</li>
<li><b>ADC12_B_SEQOFCHANNELS</b> - one time conversion of multiple channels into the specified starting memory buffer and each subsequent memory buffer up until the conversion is stored in a memory buffer dedicated as the end-of-sequence by the memory's control register.</li>
<li><b>ADC12_B_REPEATED_SINGLECHANNEL</b> - repeated conversions of one channel into a single memory buffer.</li>
<li><b>ADC12_B_REPEATED_SEQOFCHANNELS</b> - repeated conversions of multiple channels into the specified starting memory buffer and each subsequent memory buffer up until the conversion is stored in a memory buffer dedicated as the end-of-sequence by the memory's control register. <br />
 Modified bits are <b>ADC12CONSEQx</b> of <b>ADC12CTL1</b> register.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Modified bits of <b>ADC12CTL1</b> register and bits of <b>ADC12CTL0</b> register.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1" /><small>
Copyright  2017, Texas Instruments Incorporated</small>
</body>
</html>
